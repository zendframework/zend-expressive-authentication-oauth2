{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OAuth2 server middleware for Expressive and PSR-7 applications Zend-expressive-authentication-oauth2 is middleware for Expressive and PSR-7 applications providing an OAuth2 server for authentication. This library uses the league/oauth2-server package for implementing the OAuth2 server. It supports all the following grant types: client credentials; password; authorization code; implicit; refresh token; Installation You can install the zend-expressive-authentication-oauth2 library with composer: $ composer require zendframework/zend-expressive-authentication-oauth2 Documentation Browse the documentation online at https://docs.zendframework.com/zend-expressive-authentication-oauth2/ Support Issues Chat Forum","title":"Home"},{"location":"#oauth2-server-middleware-for-expressive-and-psr-7-applications","text":"Zend-expressive-authentication-oauth2 is middleware for Expressive and PSR-7 applications providing an OAuth2 server for authentication. This library uses the league/oauth2-server package for implementing the OAuth2 server. It supports all the following grant types: client credentials; password; authorization code; implicit; refresh token;","title":"OAuth2 server middleware for Expressive and PSR-7 applications"},{"location":"#installation","text":"You can install the zend-expressive-authentication-oauth2 library with composer: $ composer require zendframework/zend-expressive-authentication-oauth2","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.zendframework.com/zend-expressive-authentication-oauth2/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"authorization-server/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/authorization-server/'; });","title":"_authorizationserver"},{"location":"intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/intro/'; });","title":"_introduction"},{"location":"usage/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/usage/'; });","title":"_usage"},{"location":"grant/auth_code/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/auth_code/'; });","title":"_grant_authcode"},{"location":"grant/client_credentials/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/client_credentials/'; });","title":"_grant_clientcredentials"},{"location":"grant/implicit/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/implicit/'; });","title":"_grant_implicit"},{"location":"grant/password/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/password/'; });","title":"_grant_password"},{"location":"grant/refresh_token/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/refresh_token/'; });","title":"_grant_refreshtoken"},{"location":"v1/authenticated-user/","text":"Authenticated user Once the user is authenticated, zend-expressive-authentication-oauth2 stores the user's authorization details in a PSR-7 attribute under the name Zend\\Expressive\\Authentication\\UserInterface , using an object implementing the interface of the same name . This object contains all information discovered and/or generated by thephpleage/oauth2-server , including the following data: [ 'oauth_user_id' => /* user's identifier (string) */, 'oauth_client_id' => /* the client id (string) */, 'oauth_access_token_id' => /* the access token id (string) */, 'oauth_scopes' => /* the scopes (mixed, usually an array) */ ] You may retrieve all of these values using the getDetails() method, or individually using the getDetail($name) method, of the user instance. As an example: $user->getDetails(); // returns all the values, as array // Retrieves only the oauth_user_id value, using a default of boolean false: $userId = $user->getDetail('oauth_user_id', false); if (false !== $userId) { printf(\"The user ID is %s\", $userId); } If you want to retrieve the identity of the user (or the client), you can also use the getIdentity() method. This method returns the user's ID if it is not null; otherwise it returns the client's ID. The getRoles() method of the user instance always returns an empty array. Customize the user instance If you wish to provide a custom Zend\\Expressive\\Authentication\\UserInterface implementation, you will need to provide: a custom implementation of the the interface. a factory capable of generating instances of that implementation. a DI factory for generating the previous factory. configuration wiring the UserInterface service to your factory. The factory noted in the second step should be a callable with the following signature: function ( string $identity, array $roles = [], array $details = [] ) : Zend\\Expressive\\Authentication\\UserInterface As an example of the factory in the third point, you will create a standard DI factory to return it. It could, for instance, compose a database adapter to pull information and create your custom user implementation: use Psr\\Container\\ContainerInterface; use Zend\\Db\\Adapter\\AdapterInterface as DbAdapter; use Zend\\Expressive\\Authentication\\UserInterface; class CustomUserFactory { public function __invoke(ContainerInterface $container) : callable { $db = $container->get(DbAdapter::class); return function (string $identity, array $roles = [], array $details = []) use ($db) : UserInterface { // get some data from $db // return a new instance return new MyCustomUserType(/* ... */); }); } } You will then need to wire this factory to the UserInterface service, per the following example: // config/autoload/custom-user.local.php return [ 'dependencies' => [ 'factories' => [ UserInterface::class => CustomUserFactory::class, ], ], ];","title":"Authenticated user"},{"location":"v1/authenticated-user/#authenticated-user","text":"Once the user is authenticated, zend-expressive-authentication-oauth2 stores the user's authorization details in a PSR-7 attribute under the name Zend\\Expressive\\Authentication\\UserInterface , using an object implementing the interface of the same name . This object contains all information discovered and/or generated by thephpleage/oauth2-server , including the following data: [ 'oauth_user_id' => /* user's identifier (string) */, 'oauth_client_id' => /* the client id (string) */, 'oauth_access_token_id' => /* the access token id (string) */, 'oauth_scopes' => /* the scopes (mixed, usually an array) */ ] You may retrieve all of these values using the getDetails() method, or individually using the getDetail($name) method, of the user instance. As an example: $user->getDetails(); // returns all the values, as array // Retrieves only the oauth_user_id value, using a default of boolean false: $userId = $user->getDetail('oauth_user_id', false); if (false !== $userId) { printf(\"The user ID is %s\", $userId); } If you want to retrieve the identity of the user (or the client), you can also use the getIdentity() method. This method returns the user's ID if it is not null; otherwise it returns the client's ID. The getRoles() method of the user instance always returns an empty array.","title":"Authenticated user"},{"location":"v1/authenticated-user/#customize-the-user-instance","text":"If you wish to provide a custom Zend\\Expressive\\Authentication\\UserInterface implementation, you will need to provide: a custom implementation of the the interface. a factory capable of generating instances of that implementation. a DI factory for generating the previous factory. configuration wiring the UserInterface service to your factory. The factory noted in the second step should be a callable with the following signature: function ( string $identity, array $roles = [], array $details = [] ) : Zend\\Expressive\\Authentication\\UserInterface As an example of the factory in the third point, you will create a standard DI factory to return it. It could, for instance, compose a database adapter to pull information and create your custom user implementation: use Psr\\Container\\ContainerInterface; use Zend\\Db\\Adapter\\AdapterInterface as DbAdapter; use Zend\\Expressive\\Authentication\\UserInterface; class CustomUserFactory { public function __invoke(ContainerInterface $container) : callable { $db = $container->get(DbAdapter::class); return function (string $identity, array $roles = [], array $details = []) use ($db) : UserInterface { // get some data from $db // return a new instance return new MyCustomUserType(/* ... */); }); } } You will then need to wire this factory to the UserInterface service, per the following example: // config/autoload/custom-user.local.php return [ 'dependencies' => [ 'factories' => [ UserInterface::class => CustomUserFactory::class, ], ], ];","title":"Customize the user instance"},{"location":"v1/authorization-server/","text":"Implement an authorization server This library provides the basics for implementing an authorization server for your application. Since there are authorization flows that require user interaction, your application is expected to provide the middleware to handle this . Add the token endpoint Adding the token endpoint involves routing to the provided Zend\\Expressive\\Authentication\\OAuth2\\TokenEndpointHandler . This endpoint MUST accept POST requests. For example: use Zend\\Expressive\\Authentication\\OAuth2; $app->post('/oauth2/token', OAuth2\\TokenEndpointHandler::class); Add the authorization endpoint The authorization endpoint is the URL to which the client redirects to obtain an access token or authorization code. This endpoint MUST accept GET requests and should: Validate the request (especially for a valid client id and redirect url). Make sure the user is authenticated (for example, by showing a login prompt if needed). Optionally, request the user's consent to grant access to the client. Redirect to a specified url of the client with success or error information. The first and the last items are provided by this library. For example, to add the authorization endpoint, you can declare a middleware pipeline for the route as follows: use Zend\\Expressive\\Authentication\\OAuth2; use Zend\\Expressive\\Session\\SessionMiddleware; $app->route('/oauth2/authorize', [ SessionMiddleware::class, OAuth2\\AuthorizationMiddleware::class, // The following middleware is provided by your application (see below): App\\OAuthAuthorizationMiddleware::class, OAuth2\\AuthorizationHandler::class ], ['GET', 'POST']); In your App\\OAuthAuthorizationMiddleware , you'll have access to the League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest via the PSR-7 request. Your middleware should populate the AuthorizationRequest 's user entity via its setUser() method, and the user's consent decision via the setAuthorizationApproved() method. As an example: namespace App; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest; use Zend\\Expressive\\Authentication\\UserInterface; class OAuthAuthorizationMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Assume a middleware handled the authentication check and // populates the user object, which also implements the // OAuth2 UserEntityInterface $user = $request->getAttribute(UserInterface::class); // Assume the SessionMiddleware handles and populates a session // container $session = $request->getAttribute('session'); // This is populated by the previous middleware: /** @var AuthorizationRequest $authRequest */ $authRequest = $request->getAttribute(AuthorizationRequest::class); // The user is authenticated: if ($user) { $authRequest->setUser($user); // This assumes all clients are trusted, but you could // handle consent here, or within the next middleware // as needed. $authRequest->setAuthorizationApproved(true); return $handler->handle($request); } // The user is not authenticated, show login form ... // Store the auth request state // NOTE: Do not attempt to serialize or store the authorization // request object. Store the query parameters instead and redirect // with these to this endpoint again to replay the request. $session['oauth2_request_params'] = $request->getQueryParams(); return new RedirectResponse('/oauth2/login'); } }","title":"Authorization server"},{"location":"v1/authorization-server/#implement-an-authorization-server","text":"This library provides the basics for implementing an authorization server for your application. Since there are authorization flows that require user interaction, your application is expected to provide the middleware to handle this .","title":"Implement an authorization server"},{"location":"v1/authorization-server/#add-the-token-endpoint","text":"Adding the token endpoint involves routing to the provided Zend\\Expressive\\Authentication\\OAuth2\\TokenEndpointHandler . This endpoint MUST accept POST requests. For example: use Zend\\Expressive\\Authentication\\OAuth2; $app->post('/oauth2/token', OAuth2\\TokenEndpointHandler::class);","title":"Add the token endpoint"},{"location":"v1/authorization-server/#add-the-authorization-endpoint","text":"The authorization endpoint is the URL to which the client redirects to obtain an access token or authorization code. This endpoint MUST accept GET requests and should: Validate the request (especially for a valid client id and redirect url). Make sure the user is authenticated (for example, by showing a login prompt if needed). Optionally, request the user's consent to grant access to the client. Redirect to a specified url of the client with success or error information. The first and the last items are provided by this library. For example, to add the authorization endpoint, you can declare a middleware pipeline for the route as follows: use Zend\\Expressive\\Authentication\\OAuth2; use Zend\\Expressive\\Session\\SessionMiddleware; $app->route('/oauth2/authorize', [ SessionMiddleware::class, OAuth2\\AuthorizationMiddleware::class, // The following middleware is provided by your application (see below): App\\OAuthAuthorizationMiddleware::class, OAuth2\\AuthorizationHandler::class ], ['GET', 'POST']); In your App\\OAuthAuthorizationMiddleware , you'll have access to the League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest via the PSR-7 request. Your middleware should populate the AuthorizationRequest 's user entity via its setUser() method, and the user's consent decision via the setAuthorizationApproved() method. As an example: namespace App; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest; use Zend\\Expressive\\Authentication\\UserInterface; class OAuthAuthorizationMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Assume a middleware handled the authentication check and // populates the user object, which also implements the // OAuth2 UserEntityInterface $user = $request->getAttribute(UserInterface::class); // Assume the SessionMiddleware handles and populates a session // container $session = $request->getAttribute('session'); // This is populated by the previous middleware: /** @var AuthorizationRequest $authRequest */ $authRequest = $request->getAttribute(AuthorizationRequest::class); // The user is authenticated: if ($user) { $authRequest->setUser($user); // This assumes all clients are trusted, but you could // handle consent here, or within the next middleware // as needed. $authRequest->setAuthorizationApproved(true); return $handler->handle($request); } // The user is not authenticated, show login form ... // Store the auth request state // NOTE: Do not attempt to serialize or store the authorization // request object. Store the query parameters instead and redirect // with these to this endpoint again to replay the request. $session['oauth2_request_params'] = $request->getQueryParams(); return new RedirectResponse('/oauth2/login'); } }","title":"Add the authorization endpoint"},{"location":"v1/intro/","text":"zendframework/zend-expressive-authentication-oauth2 This component provides OAuth2 (server) authentication for Expressive and PSR-7 / PSR-15 applications. It implements Zend\\Expressive\\Authentication\\AuthenticationInterface , and it can be used as an adapter for zend-expressive-authentication . This library uses the league/oauth2-server package for implementing the OAuth2 server. If you need an introduction to OAuth2, you can read the following references: OAuth2 documentation from the Apigility project. An Introduction to OAuth 2 by DigitalOcean. The OAuth2 specification itself, via its official website. Installation In order to implement the OAuth2 server, we first need to configure it. The first step is to generate new cryptographic keys. We need to execute the script ./vendor/bin/generate-oauth2-keys in order to generate these keys. $ ./vendor/bin/generate-oauth2-keys This script will store the keys in the application's data folder if found: Private key stored in: ./data/oauth/private.key Public key stored in: ./data/oauth/public.key Encryption key stored in: ./data/oauth/encryption.key The script will generate public and private keys, and an encryption key. These keys are used by league/oauth2-server as security settings for the OAuth2 server infrastructure. Configuration The OAuth2 server is configured by the authentication configuration key in the PSR-11 container (e.g. zend-servicemanager ). The default values are: use League\\OAuth2\\Server\\Grant; return [ 'private_key' => __DIR__ . '/../data/oauth/private.key', 'public_key' => __DIR__ . '/../data/oauth/public.key', 'encryption_key' => require __DIR__ . '/../data/oauth/encryption.key', 'access_token_expire' => 'P1D', 'refresh_token_expire' => 'P1M', 'auth_code_expire' => 'PT10M', 'pdo' => [ 'dsn' => '', 'username' => '', 'password' => '' ], // Set value to null to disable a grant 'grants' => [ Grant\\ClientCredentialsGrant::class => Grant\\ClientCredentialsGrant::class, Grant\\PasswordGrant::class => Grant\\PasswordGrant::class, Grant\\AuthCodeGrant::class => Grant\\AuthCodeGrant::class, Grant\\ImplicitGrant::class => Grant\\ImplicitGrant::class, Grant\\RefreshTokenGrant::class => Grant\\RefreshTokenGrant::class ], ]; The private_key and public_key values contains the paths to the previous generated pair of keys. The encryption_key contains the encryption key value as a string, as stored in the data/oauth/encryption.key file. By default both key files are checked for correct permissions (chmod 400, 440, 600, 640 or 660 is expected, and 600 or 660 is recommended). In case the environment/operating system (e.g. Windows) does not support such a permissions, the check can be disabled: // ... 'private_key' => [ 'key_or_path' => __DIR__ . '/../data/oauth/private.key', 'key_permissions_check' => false, ], // ... The access_token_expire value is the time-to-live (TTL) value of the access token. The time period is represented using the DateInterval format in PHP. The default value is P1D (1 day). The refresh_token_expire value is the TTL used for the refresh token. The default value is 1 month. The auth_code_expire value is the TTL of the authentication code, used in the authorization code grant scenario. The default value is 10 minutes. The pdo value is for the PDO database configuration. Here we need to insert the parameters to access the OAuth2 database. These parameters are the dsn , the username , and the password , if required. The SQL structure of this database is stored in the data/oauth2.sql file. If you already have a PDO service configured, you can instead pass the service name to the pdo key as follows: return [ 'pdo' => 'myServiceName', ]; The grants array is for enabling/disabling grants. By default, all the supported grants are configured to be available. If you would like to disable any of the supplied grants, change the value for the grant to null . Additionally, you can extend this array to add your own custom grants. Configure Event Listeners Since 1.3.0 Optional The event_listeners and event_listener_providers arrays may be used to enable event listeners for events published by league\\oauth2-server . See the Authorization Server Domain Events documentation . The possible event names can be found in League\\OAuth2\\Server\\RequestEvent . Event Listeners The event_listeners key must contain an array of arrays. Each array element must contain at least 2 elements and may include a 3rd element. These roughly correspond to the arguments passed to League\\Event\\ListenerAcceptorInterface::addListener() . The first element must be a string -- either the wildcard ( * ) or a single event name . The second element must be either a callable, a concrete instance of League\\Event\\ListenerInterface , or a string pointing to your listener service instance in the container. The third element is optional, and must be an integer if provided. See the documentation for callable listeners . Event Listener Providers The event_listener_providers key must contain an array. Each array element must contain either a concrete instance of League\\Event\\ListenerProviderInterface or a string pointing to your container service instance of a listener provider. See the documentation for listener providers . Example config: return [ 'event_listeners' => [ // using a container service [ \\League\\OAuth2\\Server\\RequestEvent::CLIENT_AUTHENTICATION_FAILED, \\My\\Event\\Listener\\Service::class, ], // using a callable [ \\League\\OAuth2\\Server\\RequestEvent::ACCESS_TOKEN_ISSUED, function (\\League\\OAuth2\\Server\\RequestEvent $event) { // do something }, ], ], 'event_listener_providers' => [ \\My\\Event\\ListenerProvider\\Service::class, ], ]; OAuth2 Database You need to provide an OAuth2 database yourself, or generate a SQLite database with the following command (using sqlite3 for GNU/Linux): $ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2.sql You can also create some testing values using the data/oauth2_test.sql file: $ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2_test.sql These commands will insert the following testing values: a client client_test with secret test , used for client_credentials and the password grant type. a client client_test2 with secret test , used for authorization code and implicit grant type. a user user_test with password test . a test scope. For security reason, the client secret and the user password are stored using the bcrypt algorithm as used by the password_hash function. Configure OAuth2 Routes As the final step, in order to use the OAuth2 server you need to configure the routes for the token endpoint and authorization . You can read how add the token endpoint and the authorization routes in the Implement an authorization server section.","title":"Introduction"},{"location":"v1/intro/#zendframeworkzend-expressive-authentication-oauth2","text":"This component provides OAuth2 (server) authentication for Expressive and PSR-7 / PSR-15 applications. It implements Zend\\Expressive\\Authentication\\AuthenticationInterface , and it can be used as an adapter for zend-expressive-authentication . This library uses the league/oauth2-server package for implementing the OAuth2 server. If you need an introduction to OAuth2, you can read the following references: OAuth2 documentation from the Apigility project. An Introduction to OAuth 2 by DigitalOcean. The OAuth2 specification itself, via its official website.","title":"zendframework/zend-expressive-authentication-oauth2"},{"location":"v1/intro/#installation","text":"In order to implement the OAuth2 server, we first need to configure it. The first step is to generate new cryptographic keys. We need to execute the script ./vendor/bin/generate-oauth2-keys in order to generate these keys. $ ./vendor/bin/generate-oauth2-keys This script will store the keys in the application's data folder if found: Private key stored in: ./data/oauth/private.key Public key stored in: ./data/oauth/public.key Encryption key stored in: ./data/oauth/encryption.key The script will generate public and private keys, and an encryption key. These keys are used by league/oauth2-server as security settings for the OAuth2 server infrastructure.","title":"Installation"},{"location":"v1/intro/#configuration","text":"The OAuth2 server is configured by the authentication configuration key in the PSR-11 container (e.g. zend-servicemanager ). The default values are: use League\\OAuth2\\Server\\Grant; return [ 'private_key' => __DIR__ . '/../data/oauth/private.key', 'public_key' => __DIR__ . '/../data/oauth/public.key', 'encryption_key' => require __DIR__ . '/../data/oauth/encryption.key', 'access_token_expire' => 'P1D', 'refresh_token_expire' => 'P1M', 'auth_code_expire' => 'PT10M', 'pdo' => [ 'dsn' => '', 'username' => '', 'password' => '' ], // Set value to null to disable a grant 'grants' => [ Grant\\ClientCredentialsGrant::class => Grant\\ClientCredentialsGrant::class, Grant\\PasswordGrant::class => Grant\\PasswordGrant::class, Grant\\AuthCodeGrant::class => Grant\\AuthCodeGrant::class, Grant\\ImplicitGrant::class => Grant\\ImplicitGrant::class, Grant\\RefreshTokenGrant::class => Grant\\RefreshTokenGrant::class ], ]; The private_key and public_key values contains the paths to the previous generated pair of keys. The encryption_key contains the encryption key value as a string, as stored in the data/oauth/encryption.key file. By default both key files are checked for correct permissions (chmod 400, 440, 600, 640 or 660 is expected, and 600 or 660 is recommended). In case the environment/operating system (e.g. Windows) does not support such a permissions, the check can be disabled: // ... 'private_key' => [ 'key_or_path' => __DIR__ . '/../data/oauth/private.key', 'key_permissions_check' => false, ], // ... The access_token_expire value is the time-to-live (TTL) value of the access token. The time period is represented using the DateInterval format in PHP. The default value is P1D (1 day). The refresh_token_expire value is the TTL used for the refresh token. The default value is 1 month. The auth_code_expire value is the TTL of the authentication code, used in the authorization code grant scenario. The default value is 10 minutes. The pdo value is for the PDO database configuration. Here we need to insert the parameters to access the OAuth2 database. These parameters are the dsn , the username , and the password , if required. The SQL structure of this database is stored in the data/oauth2.sql file. If you already have a PDO service configured, you can instead pass the service name to the pdo key as follows: return [ 'pdo' => 'myServiceName', ]; The grants array is for enabling/disabling grants. By default, all the supported grants are configured to be available. If you would like to disable any of the supplied grants, change the value for the grant to null . Additionally, you can extend this array to add your own custom grants.","title":"Configuration"},{"location":"v1/intro/#oauth2-database","text":"You need to provide an OAuth2 database yourself, or generate a SQLite database with the following command (using sqlite3 for GNU/Linux): $ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2.sql You can also create some testing values using the data/oauth2_test.sql file: $ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2_test.sql These commands will insert the following testing values: a client client_test with secret test , used for client_credentials and the password grant type. a client client_test2 with secret test , used for authorization code and implicit grant type. a user user_test with password test . a test scope. For security reason, the client secret and the user password are stored using the bcrypt algorithm as used by the password_hash function.","title":"OAuth2 Database"},{"location":"v1/intro/#configure-oauth2-routes","text":"As the final step, in order to use the OAuth2 server you need to configure the routes for the token endpoint and authorization . You can read how add the token endpoint and the authorization routes in the Implement an authorization server section.","title":"Configure OAuth2 Routes"},{"location":"v1/usage/","text":"Usage If you successfully configured the OAuth2 server as detailed in the installation section, you can request an access token using the OAuth2 server route you defined (e.g. /oauth ). You can require an access token using one of the following scenarios: client credentials ; password ; authorization code ; implicit ; refresh token . Authenticate a middleware This library uses the authentication abstraction of the Zend\\Expressive\\Authentication\\AuthenticationMiddleware class provided by zend-expressive-authentication . In order to use OAuth2, we need to configure the service Zend\\Expressive\\Authentication\\AuthenticationInterface to resolve to Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Adapter . This can be achieved using the following configuration: use Zend\\Expressive\\Authentication; return [ 'dependencies' => [ 'aliases' => [ Authentication\\AuthenticationInterface::class => Authentication\\OAuth2\\OAuth2Adapter::class, ], ], ]; The previous configuration will instruct zend-expressive-authentication to use the OAuth2 adapter provided in this package. (Unlike other adapters, this adapter does not require a Zend\\Expressive\\Authentication\\UserRepositoryInterface ; the OAuth2 database with user and client credentials is managed by the component itself.) When the service alias is configured, you can immediately begin authenticating your application/API by adding the AuthenticationMiddleware to either your application or route-specific middleware pipeline. For instance, using an Expressive application, you could add it to a specific route, as follows: $app->post('/api/users', [ Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Action\\AddUserAction::class, ], 'api.add.user'); Providing an authorization server See the chapter Authorization server for details on how to implement this.","title":"Usage"},{"location":"v1/usage/#usage","text":"If you successfully configured the OAuth2 server as detailed in the installation section, you can request an access token using the OAuth2 server route you defined (e.g. /oauth ). You can require an access token using one of the following scenarios: client credentials ; password ; authorization code ; implicit ; refresh token .","title":"Usage"},{"location":"v1/usage/#authenticate-a-middleware","text":"This library uses the authentication abstraction of the Zend\\Expressive\\Authentication\\AuthenticationMiddleware class provided by zend-expressive-authentication . In order to use OAuth2, we need to configure the service Zend\\Expressive\\Authentication\\AuthenticationInterface to resolve to Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Adapter . This can be achieved using the following configuration: use Zend\\Expressive\\Authentication; return [ 'dependencies' => [ 'aliases' => [ Authentication\\AuthenticationInterface::class => Authentication\\OAuth2\\OAuth2Adapter::class, ], ], ]; The previous configuration will instruct zend-expressive-authentication to use the OAuth2 adapter provided in this package. (Unlike other adapters, this adapter does not require a Zend\\Expressive\\Authentication\\UserRepositoryInterface ; the OAuth2 database with user and client credentials is managed by the component itself.) When the service alias is configured, you can immediately begin authenticating your application/API by adding the AuthenticationMiddleware to either your application or route-specific middleware pipeline. For instance, using an Expressive application, you could add it to a specific route, as follows: $app->post('/api/users', [ Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Action\\AddUserAction::class, ], 'api.add.user');","title":"Authenticate a middleware"},{"location":"v1/usage/#providing-an-authorization-server","text":"See the chapter Authorization server for details on how to implement this.","title":"Providing an authorization server"},{"location":"v1/grant/auth_code/","text":"Authorization code The authorization code is used to authenticate a web application with a third-party service (e.g., imagine you built a web application that needs to consume the API of Facebook). You can authenticate your application using the third-party server with a 4-step flow as illustrated in this diagram: The web application sends a request (including the client_id and the redirect_uri ) to the authorization server asking for an authorization code (1). The authorization server shows an allow/deny page to the end-user requesting authorization for access. If the user clicks on \"Allow\", the server sends the authorization code to the web application using the redirect_uri (2). The web application can now perform a token request, passing the client_id , the redirect_uri , the client_secret , and the authentication code to prove that it is authorized to perform the request (3). The authorization server sends the access token in the response if the request is valid (4). Request the authorization code The client sends the following parameters via query string arguments to the authorization server: response_type = code. client_id with the client identifer. redirect_uri with the URI to which to redirect the client following successful authorization. This parameter is optional, but if it is not sent, the user will be redirected to a default location on completion. scope with a space-delimited list of requested scope permissions. state with a Cross-Site Request Forgery (CSRF) token. This parameter is optional, but highly recommended. You can store the value of the CSRF token in the user\u2019s session to be validated in the next step. The user will then be asked to login to the authorization server and approve the client request. If the user approves the request they will be redirected to the redirect URI with the following parameters in the query string arguments: code with the authorization code. state with the CSRF parameter sent in the original request. You can compare this value with the one stored in the user\u2019s session. Request the access token The client sends a POST request to the authorization server with the following parameters: grant_type = authorization_code. client_id with the client\u2019s ID. client_secret with the client\u2019s secret. redirect_uri with the previous client redirect URI. code with the authorization code as returned in the authorization code request (as detailed in the previous section). The authorization server responds with a JSON payload similar to the following: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The values are as follows: The token_type is the type of generated token (here, and generally, \"Bearer\"). The expires_in value is an integer representing the time-to-live (in seconds) of the access token. The refresh_token is a token that can be used to refresh the access_token when expired. The access_token contains a JSON Web Token (JWT) signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header on subsequent requests.","title":"Authorization code"},{"location":"v1/grant/auth_code/#authorization-code","text":"The authorization code is used to authenticate a web application with a third-party service (e.g., imagine you built a web application that needs to consume the API of Facebook). You can authenticate your application using the third-party server with a 4-step flow as illustrated in this diagram: The web application sends a request (including the client_id and the redirect_uri ) to the authorization server asking for an authorization code (1). The authorization server shows an allow/deny page to the end-user requesting authorization for access. If the user clicks on \"Allow\", the server sends the authorization code to the web application using the redirect_uri (2). The web application can now perform a token request, passing the client_id , the redirect_uri , the client_secret , and the authentication code to prove that it is authorized to perform the request (3). The authorization server sends the access token in the response if the request is valid (4).","title":"Authorization code"},{"location":"v1/grant/auth_code/#request-the-authorization-code","text":"The client sends the following parameters via query string arguments to the authorization server: response_type = code. client_id with the client identifer. redirect_uri with the URI to which to redirect the client following successful authorization. This parameter is optional, but if it is not sent, the user will be redirected to a default location on completion. scope with a space-delimited list of requested scope permissions. state with a Cross-Site Request Forgery (CSRF) token. This parameter is optional, but highly recommended. You can store the value of the CSRF token in the user\u2019s session to be validated in the next step. The user will then be asked to login to the authorization server and approve the client request. If the user approves the request they will be redirected to the redirect URI with the following parameters in the query string arguments: code with the authorization code. state with the CSRF parameter sent in the original request. You can compare this value with the one stored in the user\u2019s session.","title":"Request the authorization code"},{"location":"v1/grant/auth_code/#request-the-access-token","text":"The client sends a POST request to the authorization server with the following parameters: grant_type = authorization_code. client_id with the client\u2019s ID. client_secret with the client\u2019s secret. redirect_uri with the previous client redirect URI. code with the authorization code as returned in the authorization code request (as detailed in the previous section). The authorization server responds with a JSON payload similar to the following: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The values are as follows: The token_type is the type of generated token (here, and generally, \"Bearer\"). The expires_in value is an integer representing the time-to-live (in seconds) of the access token. The refresh_token is a token that can be used to refresh the access_token when expired. The access_token contains a JSON Web Token (JWT) signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header on subsequent requests.","title":"Request the access token"},{"location":"v1/grant/client_credentials/","text":"Client credentials The client credentials grant is used in machine-to-machine scenarios. For example, you would use it with a client making API requests that do not require a user's permission. The client sends a POST request with the following body parameters to the authorization server: grant_type = client_credentials. client_id with the client's ID. client_secret with the client's secret. scope with a space-delimited list of requested scope permissions. The authorization server responds with a JSON payload as follows: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The values returned are as follows: The token_type is the type of generated token (here, and generally, Bearer). expires_in is an integer representing the time-to-live (in seconds) of the access token. The access_token contains a JSON Web Token (JWT) signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header in subsequent requests.","title":"Client credentials"},{"location":"v1/grant/client_credentials/#client-credentials","text":"The client credentials grant is used in machine-to-machine scenarios. For example, you would use it with a client making API requests that do not require a user's permission. The client sends a POST request with the following body parameters to the authorization server: grant_type = client_credentials. client_id with the client's ID. client_secret with the client's secret. scope with a space-delimited list of requested scope permissions. The authorization server responds with a JSON payload as follows: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The values returned are as follows: The token_type is the type of generated token (here, and generally, Bearer). expires_in is an integer representing the time-to-live (in seconds) of the access token. The access_token contains a JSON Web Token (JWT) signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header in subsequent requests.","title":"Client credentials"},{"location":"v1/grant/implicit/","text":"Implicit grant The implicit grant is similar to the authorization code grant, with two differences: it's used for user-agent-based clients (e.g. single page applications) that cannot store a secret in a secure way; additionally, the authorization server returns the access token directly, without the need of an authorization code. The client sends the following parameter via a query string argument to the authorization server: response_type = token. client_id , with the client\u2019s ID. redirect_uri , with the URI to which to redirect the client after completing authorization. This parameter is optional; if not provided, however, the user will be redirected to a default location. scope , with a space-delimited list of requested scope permissions. state , with a Cross-Site Request Forgery (CSRF) token. This parameter is optional but highly recommended. You can store the value of CSRF token in the user\u2019s session to be validated in the next step. The user will then be asked to login to the authorization server and approve the client request. If the user approves the request, they will be redirected to the redirect URI with the following parameters in the query string arguments: token_type = Bearer. expires_in , an integer representing the time-to-live (in seconds) of the access token. access_token , the access token represented by a JSON Web Token (JWT) signed with the authorization server\u2019s private key. state , with the CSRF parameter sent in the original request. You can compare this value with the one stored in the user\u2019s session. Refresh tokens are not to be issued for implicit grants. This is a security restriction coming from the OAuth2 specification, RFC 6749 .","title":"Implicit"},{"location":"v1/grant/implicit/#implicit-grant","text":"The implicit grant is similar to the authorization code grant, with two differences: it's used for user-agent-based clients (e.g. single page applications) that cannot store a secret in a secure way; additionally, the authorization server returns the access token directly, without the need of an authorization code. The client sends the following parameter via a query string argument to the authorization server: response_type = token. client_id , with the client\u2019s ID. redirect_uri , with the URI to which to redirect the client after completing authorization. This parameter is optional; if not provided, however, the user will be redirected to a default location. scope , with a space-delimited list of requested scope permissions. state , with a Cross-Site Request Forgery (CSRF) token. This parameter is optional but highly recommended. You can store the value of CSRF token in the user\u2019s session to be validated in the next step. The user will then be asked to login to the authorization server and approve the client request. If the user approves the request, they will be redirected to the redirect URI with the following parameters in the query string arguments: token_type = Bearer. expires_in , an integer representing the time-to-live (in seconds) of the access token. access_token , the access token represented by a JSON Web Token (JWT) signed with the authorization server\u2019s private key. state , with the CSRF parameter sent in the original request. You can compare this value with the one stored in the user\u2019s session. Refresh tokens are not to be issued for implicit grants. This is a security restriction coming from the OAuth2 specification, RFC 6749 .","title":"Implicit grant"},{"location":"v1/grant/password/","text":"Password This use case allows authentication to an API using the user's credentials (generally a username and password). The typical scenario includes a \"Login\" web page that captures a username and password combination that is used to authenticate against a first-party API. Password grant is only appropriate for trusted clients . If you build your own website as a client of your API, then this is a great way to handle logging in. The client sends a POST request with following parameters: grant_type = password. client_id with the client\u2019s ID. client_secret with the client\u2019s secret. scope with a space-delimited list of requested scope permissions. username with the user\u2019s username. password with the user\u2019s password. The authorization server responds with a JSON as follows: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The token_type is the type of generated token (Bearer). The expires_in is an integer representing the TTL (in seconds) of the access token. The refresh_token a token that can be used to refresh the access_token when expired. The access_token contains a JWT signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header.","title":"Password"},{"location":"v1/grant/password/#password","text":"This use case allows authentication to an API using the user's credentials (generally a username and password). The typical scenario includes a \"Login\" web page that captures a username and password combination that is used to authenticate against a first-party API. Password grant is only appropriate for trusted clients . If you build your own website as a client of your API, then this is a great way to handle logging in. The client sends a POST request with following parameters: grant_type = password. client_id with the client\u2019s ID. client_secret with the client\u2019s secret. scope with a space-delimited list of requested scope permissions. username with the user\u2019s username. password with the user\u2019s password. The authorization server responds with a JSON as follows: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The token_type is the type of generated token (Bearer). The expires_in is an integer representing the TTL (in seconds) of the access token. The refresh_token a token that can be used to refresh the access_token when expired. The access_token contains a JWT signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header.","title":"Password"},{"location":"v1/grant/refresh_token/","text":"Refresh token The OAuth2 framework provides the ability to refresh the access token, generating a new one with a new lifetime. This action can be performed using the refresh_token value, if present in the access token response. To request a token refresh, the client needs to send a POST request with the following parameters: grant_type = refresh_token. refresh_token with the refresh token. client_id with the client\u2019s ID. client_secret with the client\u2019s secret. scope with a space-delimited list of requested scope permissions. This is optional; if not sent, the original scopes will be used. Otherwise you can request a reduced scope; you may never expand scope during a refresh operation. The authorization server responds with a JSON payload as follows: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The values are as follows: The token_type is the type of generated token (here, and generally, Bearer). expires_in is an integer representing the time-to-live (in seconds) of the access token. The refresh_token a token that can be used to refresh the access_token when expired. The access_token contains a JSON Web Token (JWT) signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header on all subsequent requests.","title":"Refresh token"},{"location":"v1/grant/refresh_token/#refresh-token","text":"The OAuth2 framework provides the ability to refresh the access token, generating a new one with a new lifetime. This action can be performed using the refresh_token value, if present in the access token response. To request a token refresh, the client needs to send a POST request with the following parameters: grant_type = refresh_token. refresh_token with the refresh token. client_id with the client\u2019s ID. client_secret with the client\u2019s secret. scope with a space-delimited list of requested scope permissions. This is optional; if not sent, the original scopes will be used. Otherwise you can request a reduced scope; you may never expand scope during a refresh operation. The authorization server responds with a JSON payload as follows: { \"token_type\" : \"Bearer\", \"expires_in\" : \"3600\", \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\", \"access_token\" : \"eyJ0eXAiOiJKV1Q...\" } The values are as follows: The token_type is the type of generated token (here, and generally, Bearer). expires_in is an integer representing the time-to-live (in seconds) of the access token. The refresh_token a token that can be used to refresh the access_token when expired. The access_token contains a JSON Web Token (JWT) signed with the authorization server\u2019s private key. This token must be used in the Authorization request HTTP header on all subsequent requests.","title":"Refresh token"}]}